---
title: "Dizajniranje reconnect-safe WebSocket sloja"
excerpt: "Kako izgraditi otporan WebSocket connection manager koji se nosi sa prekidima veze, redom poruka i sinhronizacijom stanja bez gubitka podataka."
date: "2026-01-10"
tags: ["websockets", "real-time", "architecture"]
---

# Dizajniranje reconnect-safe WebSocket sloja

Real-time sistemi zahtevaju pouzdane konekcije. Evo kako sam pristupio izgradnji WebSocket sloja koji preživljava prekide mreže.

## Problem

Standardne WebSocket implementacije tiho otkazuju. Kada se veza prekine:

- Poruke se gube
- Stanje postaje nekonzistentno
- Klijenti moraju ručno da upravljaju ponovnim povezivanjem

## Arhitektura rešenja

### 1. Connection Manager

```typescript
class WebSocketManager {
  private ws: WebSocket | null = null;
  private messageQueue: Message[] = [];
  private reconnectAttempts = 0;
  private maxReconnectDelay = 30000; // 30s

  connect() {
    this.ws = new WebSocket(this.url);
    this.setupEventHandlers();
  }

  private handleDisconnect() {
    // Eksponencijalno odlaganje
    const delay = Math.min(
      1000 * Math.pow(2, this.reconnectAttempts),
      this.maxReconnectDelay,
    );

    setTimeout(() => this.connect(), delay);
    this.reconnectAttempts++;
  }
}
```

### 2. Red poruka

Poruke u redu tokom prekida veze:

```typescript
send(message: Message) {
  if (this.isConnected()) {
    this.ws.send(JSON.stringify(message));
  } else {
    this.messageQueue.push(message);
  }
}

private flushQueue() {
  while (this.messageQueue.length > 0) {
    const msg = this.messageQueue.shift();
    this.ws.send(JSON.stringify(msg));
  }
}
```

### 3. Sinhronizacija stanja

Pri ponovnom povezivanju, sinhronizuj stanje sa serverom:

```typescript
private async onReconnect() {
  const lastMessageId = this.getLastReceivedId();

  // Zatraži propuštene poruke
  await this.send({
    type: 'SYNC',
    lastMessageId
  });

  this.flushQueue();
}
```

## Kompromisi

**Prednosti:**

- Nula gubitka poruka
- Automatsko ponovno povezivanje
- Transparentno za aplikacioni sloj

**Mane:**

- Memorijski overhead za red
- Kompleksnost u upravljanju stanjem
- Potencijalna duplikacija poruka (zahteva idempotentnost)

## Naučene lekcije

1. **Eksponencijalno odlaganje je suštinsko** - sprečava thundering herd
2. **Ograničenja veličine reda su važna** - sprečavaju curenje memorije
3. **Server-side stanje je kritično** - klijenti moraju moći da se resinhronizuju

Ovaj pristup radi u produkciji 18 meseci na 200+ uređaja sa 99.97% uptime-om.

## Šta bih promenio na većoj skali

- Implementirati kompresiju poruka
- Dodati prioritetni red
- Koristiti Redis za server-side skladištenje poruka
- Implementirati WebSocket clustering sa sticky sessions
