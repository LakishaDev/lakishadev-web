---
title: "Дизајнирање reconnect-safe WebSocket слоја"
excerpt: "Како изградити отпоран WebSocket connection manager који се носи са прекидима везе, редом порука и синхронизацијом стања без губитка података."
date: "2026-01-10"
tags: ["websockets", "real-time", "architecture"]
---

# Дизајнирање reconnect-safe WebSocket слоја

Real-time системи захтевају поуздане конекције. Ево како сам приступио изградњи WebSocket слоја који преживљава прекиде мреже.

## Проблем

Стандардне WebSocket имплементације тихо отказују. Када се веза прекине:

- Поруке се губе
- Стање постаје неконзистентно
- Клијенти морају ручно да управљају поновним повезивањем

## Архитектура решења

### 1. Connection Manager

```typescript
class WebSocketManager {
  private ws: WebSocket | null = null;
  private messageQueue: Message[] = [];
  private reconnectAttempts = 0;
  private maxReconnectDelay = 30000; // 30s

  connect() {
    this.ws = new WebSocket(this.url);
    this.setupEventHandlers();
  }

  private handleDisconnect() {
    // Експоненцијално одлагање
    const delay = Math.min(
      1000 * Math.pow(2, this.reconnectAttempts),
      this.maxReconnectDelay,
    );

    setTimeout(() => this.connect(), delay);
    this.reconnectAttempts++;
  }
}
```

### 2. Ред порука

Поруке у реду током прекида везе:

```typescript
send(message: Message) {
  if (this.isConnected()) {
    this.ws.send(JSON.stringify(message));
  } else {
    this.messageQueue.push(message);
  }
}

private flushQueue() {
  while (this.messageQueue.length > 0) {
    const msg = this.messageQueue.shift();
    this.ws.send(JSON.stringify(msg));
  }
}
```

### 3. Синхронизација стања

При поновном повезивању, синхронизуј стање са сервером:

```typescript
private async onReconnect() {
  const lastMessageId = this.getLastReceivedId();

  // Затражи пропуштене поруке
  await this.send({
    type: 'SYNC',
    lastMessageId
  });

  this.flushQueue();
}
```

## Компромиси

**Предности:**

- Нула губитка порука
- Аутоматско поновно повезивање
- Транспарентно за апликациони слој

**Мане:**

- Меморијски overhead за ред
- Комплексност у управљању стањем
- Потенцијална дупликација порука (захтева идемпотентност)

## Научене лекције

1. **Експоненцијално одлагање је суштинско** - спречава thundering herd
2. **Ограничења величине реда су важна** - спречавају цурење меморије
3. **Server-side стање је критично** - клијенти морају моћи да се ресинхронизују

Овај приступ ради у продукцији 18 месеци на 200+ уређаја са 99.97% uptime-ом.

## Шта бих променио на већој скали

- Имплементирати компресију порука
- Додати приоритетни ред
- Користити Redis за server-side складиштење порука
- Имплементирати WebSocket clustering са sticky sessions
